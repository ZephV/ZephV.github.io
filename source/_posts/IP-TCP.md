---
title: TCP/IP协议
date: 
tags: [TCP]
---

# 网络基础

**IP地址** 唯一的标识

**协议** 共同语言

**端口号** 辨别应用程序0~65535 0 ~1023

## TCP/IP协议

TCP/IP是应用最为广泛的协议。

是以TCP和IP为基础不同层次上协议的集合，也称为“TCP/IP协议族”

TCP 是传输控制协议
IP 是	互联网协议

TCP/IP模型 分为应用/传输/网络/数据连接/物理五层
Http80  FTP21 SMTP Telnet23

**IP地址** 唯一的标识

**协议** 共同语言

**端口号** 辨别应用程序
0~65535 0 ~1023

IP地址和端口号组成所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点,是TCP和UDP的终结点

Java中的网络支持
InetAddress 标识IP地址
URL
Sockets 
Datagram UDP

### 三次握手

每发送一次代表一次握手。

***客户端***（`SYN_SEND`状态）——发送TCP协议中的SYN包——>***服务器*** 

***服务器***（接收到包后进入`SYN_RECV`状态）——发送TCP协议中的SYN+ACK包——>***客户端*** 

***客户端***（接收到包后进入`ESTABLISHED`状态）——发送TCP协议中的SYN+ACK包——>***服务器*** （收包后***服务器***也进入`ESTABLISHED`状态）

#### 为什么要三次握手？

第一次和第二次,为了确认***服务器***能正确的收到了***客户端***的信息并能回应***客户端***。

第二次和第三次 ,为了确认***客户端***能正确的收到了***服务器***的回应信息并能再回应***服务器***。

以此确保信息是双工的

### 四次挥手

***客户端*** （应用底层调用`close()`会发送一个TCP协议的FIN）——>***服务器*** 请求关闭***客户端*** 到***服务器*** 的数据传输

***服务器*** 　收到请求后进行发送两条信息　——TCP协议中的ACK——＞***客户端*** 确认关闭请求

***服务器*** （应用底层调用`close()`会发送一个TCP协议的FIN）　——TCP协议中的FIN——＞***客户端*** 　请求关闭***服务器*** 到***客户端*** 的数据传输

***客户端*** 　——TCP协议中的ACK——＞***服务器*** 确认关闭请求

上述中客户端和服务器的状态为：

`WAIT`状态 -->`WAIT`状态 

`WAIT`状态 -->`WAIT`状态 

`LAST__ACK`状态 -->`WAIT`状态

`TIME WAIT `状态在2MS后`CLOSED`状态 -->`CLOSED`状态 

#### 为什么要四次挥手？

因为***服务器***再LISTEN状态下的SOCKET收到SYN请求连接后后把ACK和SYN（ACK确认作用,SYN同步作用）放在一起发送,所以进行三次握手。而关闭连接时,FIN服务器一FIN报文收到底层就做出ACK回应,而服务器的是关闭请求是由应用底层调用`close()`激发的,所以FIN和ACK在发送时间上是分开的不能同时发送。

#### 为什么 TIME_WAIT 状态还需要等 2MS L后才能返回到 CLOSED 状态？

这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 `CLOSED` 状态（就好比从 `SYN_SEND` 状态到 `ESTABLISH` 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 `LAST_ACK` 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个` TIME_WAIT` 状态的作用就是用来重发可能丢失的 ACK 报文。



